---
title: 'Comparadores de valores: EF Core'
description: Usar comparadores de valores para controlar cómo EF Core compara los valores de propiedad
author: ajcvickers
ms.date: 01/16/2021
uid: core/modeling/value-comparers
ms.openlocfilehash: 9318b41479b43b327c76a11cc99b4f7695fa88d3
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023905"
---
# <a name="value-comparers"></a><span data-ttu-id="2167d-103">Comparadores de valores</span><span class="sxs-lookup"><span data-stu-id="2167d-103">Value Comparers</span></span>

> [!NOTE]
> <span data-ttu-id="2167d-104">Esta característica se incluyó por primera vez en EF Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="2167d-104">This feature was introduced in EF Core 3.0.</span></span>

> [!TIP]
> <span data-ttu-id="2167d-105">El código de este documento se puede encontrar en GitHub como un [ejemplo ejecutable](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/).</span><span class="sxs-lookup"><span data-stu-id="2167d-105">The code in this document can be found on GitHub as a [runnable sample](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/).</span></span>

## <a name="background"></a><span data-ttu-id="2167d-106">Fondo</span><span class="sxs-lookup"><span data-stu-id="2167d-106">Background</span></span>

<span data-ttu-id="2167d-107">El [seguimiento de cambios](xref:core/change-tracking/index) significa que EF Core determina automáticamente qué cambios realizó la aplicación en una instancia de entidad cargada, de modo que esos cambios se pueden volver a guardar en la base de datos cuando <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> se llama a.</span><span class="sxs-lookup"><span data-stu-id="2167d-107">[Change tracking](xref:core/change-tracking/index) means that EF Core automatically determines what changes were performed by the application on a loaded entity instance, so that those changes can be saved back to the database when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="2167d-108">Normalmente, EF Core realiza esta tarea tomando una *instantánea* de la instancia cuando se carga desde la base de datos y *comparando* esa instantánea con la instancia entregada a la aplicación.</span><span class="sxs-lookup"><span data-stu-id="2167d-108">EF Core usually performs this by taking a *snapshot* of the instance when it's loaded from the database, and *comparing* that snapshot to the instance handed out to the application.</span></span>

<span data-ttu-id="2167d-109">EF Core incluye lógica integrada para la creación de instantáneas y la comparación de la mayoría de los tipos estándar que se usan en las bases de datos, por lo que los usuarios no suelen tener que preocuparse de este tema.</span><span class="sxs-lookup"><span data-stu-id="2167d-109">EF Core comes with built-in logic for snapshotting and comparing most standard types used in databases, so users don't usually need to worry about this topic.</span></span> <span data-ttu-id="2167d-110">Sin embargo, cuando se asigna una propiedad a través de un [convertidor de valores](xref:core/modeling/value-conversions), EF Core debe realizar la comparación en los tipos de usuario arbitrarios, que pueden ser complejos.</span><span class="sxs-lookup"><span data-stu-id="2167d-110">However, when a property is mapped through a [value converter](xref:core/modeling/value-conversions), EF Core needs to perform comparison on arbitrary user types, which may be complex.</span></span> <span data-ttu-id="2167d-111">De forma predeterminada, EF Core usa la comparación de igualdad predeterminada definida por los tipos (por ejemplo `Equals` , el método); para la toma de instantáneas, los [tipos de valor](/dotnet/csharp/language-reference/builtin-types/value-types) se copian para generar la instantánea, mientras que para los [tipos de referencia](/dotnet/csharp/language-reference/keywords/reference-types) no se realiza ninguna copia y se usa la misma instancia como la instantánea.</span><span class="sxs-lookup"><span data-stu-id="2167d-111">By default, EF Core uses the default equality comparison defined by types (e.g. the `Equals` method); for snapshotting, [value types](/dotnet/csharp/language-reference/builtin-types/value-types) are copied to produce the snapshot, while for [reference types](/dotnet/csharp/language-reference/keywords/reference-types) no copying occurs, and the same instance is used as the snapshot.</span></span>

<span data-ttu-id="2167d-112">En los casos en los que el comportamiento de comparación integrado no es adecuado, los usuarios pueden proporcionar un *comparador de valores*, que contiene la lógica para la toma de instantáneas, la comparación y el cálculo de un código hash.</span><span class="sxs-lookup"><span data-stu-id="2167d-112">In cases where the built-in comparison behavior isn't appropriate, users may provide a *value comparer*, which contains logic for snapshotting, comparing and calculating a hash code.</span></span> <span data-ttu-id="2167d-113">Por ejemplo, lo siguiente configura la conversión de valores para `List<int>` que la propiedad se convierta en una cadena JSON en la base de datos y define también un comparador de valores adecuado:</span><span class="sxs-lookup"><span data-stu-id="2167d-113">For example, the following sets up value conversion for `List<int>` property to be value converted to a JSON string in the database, and defines an appropriate value comparer as well:</span></span>

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty)]

<span data-ttu-id="2167d-114">Vea [clases mutables](#mutable-classes) a continuación para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="2167d-114">See [mutable classes](#mutable-classes) below for further details.</span></span>

<span data-ttu-id="2167d-115">Tenga en cuenta que los comparadores de valores también se usan para determinar si dos valores de clave son iguales al resolver las relaciones; Esto se explica a continuación.</span><span class="sxs-lookup"><span data-stu-id="2167d-115">Note that value comparers are also used when determining whether two key values are the same when resolving relationships; this is explained below.</span></span>

## <a name="shallow-vs-deep-comparison"></a><span data-ttu-id="2167d-116">Comparación superficial frente a profunda</span><span class="sxs-lookup"><span data-stu-id="2167d-116">Shallow vs. deep comparison</span></span>

<span data-ttu-id="2167d-117">En el caso de los tipos de valor pequeños e inmutables como `int` , la lógica predeterminada de EF Core funciona bien: el valor se copia tal cual cuando se realiza instantáneas y se compara con la comparación de igualdad integrada del tipo.</span><span class="sxs-lookup"><span data-stu-id="2167d-117">For small, immutable value types such as `int`, EF Core's default logic works well: the value is copied as-is when snapshotted, and compared with the type's built-in equality comparison.</span></span> <span data-ttu-id="2167d-118">Al implementar su propio comparador de valores, es importante tener en cuenta si la lógica de comparación profunda o superficial (y de la instantánea) es adecuada.</span><span class="sxs-lookup"><span data-stu-id="2167d-118">When implementing your own value comparer, it's important to consider whether deep or shallow comparison (and snapshotting) logic is appropriate.</span></span>

<span data-ttu-id="2167d-119">Considere las matrices de bytes, que pueden ser arbitrariamente grandes.</span><span class="sxs-lookup"><span data-stu-id="2167d-119">Consider byte arrays, which can be arbitrarily large.</span></span> <span data-ttu-id="2167d-120">Se pueden comparar:</span><span class="sxs-lookup"><span data-stu-id="2167d-120">These could be compared:</span></span>

* <span data-ttu-id="2167d-121">Por referencia, de modo que solo se detecta una diferencia si se usa una nueva matriz de bytes</span><span class="sxs-lookup"><span data-stu-id="2167d-121">By reference, such that a difference is only detected if a new byte array is used</span></span>
* <span data-ttu-id="2167d-122">Mediante una comparación profunda, de modo que se detecta la mutación de los bytes de la matriz</span><span class="sxs-lookup"><span data-stu-id="2167d-122">By deep comparison, such that mutation of the bytes in the array is detected</span></span>

<span data-ttu-id="2167d-123">De forma predeterminada, EF Core usa el primero de estos enfoques para las matrices de bytes que no son de clave.</span><span class="sxs-lookup"><span data-stu-id="2167d-123">By default, EF Core uses the first of these approaches for non-key byte arrays.</span></span> <span data-ttu-id="2167d-124">Es decir, solo se comparan las referencias y se detecta un cambio solo cuando una matriz de bytes existente se reemplaza por otra nueva.</span><span class="sxs-lookup"><span data-stu-id="2167d-124">That is, only references are compared and a change is detected only when an existing byte array is replaced with a new one.</span></span> <span data-ttu-id="2167d-125">Se trata de una decisión pragmática que evita copiar matrices completas y compararlas de byte a byte al ejecutarse <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> .</span><span class="sxs-lookup"><span data-stu-id="2167d-125">This is a pragmatic decision that avoids copying entire arrays and comparing them byte-to-byte when executing <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>.</span></span> <span data-ttu-id="2167d-126">Significa que el escenario común de sustitución, por ejemplo, de una imagen por otra, se trata de un modo eficaz.</span><span class="sxs-lookup"><span data-stu-id="2167d-126">It means that the common scenario of replacing, say, one image with another is handled in a performant way.</span></span>

<span data-ttu-id="2167d-127">Por otro lado, la igualdad de referencia no funcionaría cuando se usan matrices de bytes para representar claves binarias, ya que es muy poco probable que una propiedad FK esté establecida en la _misma instancia_ que una propiedad PK en la que se debe comparar.</span><span class="sxs-lookup"><span data-stu-id="2167d-127">On the other hand, reference equality would not work when byte arrays are used to represent binary keys, since it's very unlikely that an FK property is set to the _same instance_ as a PK property to which it needs to be compared.</span></span> <span data-ttu-id="2167d-128">Por lo tanto, EF Core utiliza comparaciones en profundidad para las matrices de bytes que actúan como claves. no es probable que esto afecte al rendimiento, ya que las claves binarias suelen ser cortas.</span><span class="sxs-lookup"><span data-stu-id="2167d-128">Therefore, EF Core uses deep comparisons for byte arrays acting as keys; this is unlikely to have a big performance hit since binary keys are usually short.</span></span>

<span data-ttu-id="2167d-129">Tenga en cuenta que la comparación y la lógica de la instantánea elegidos deben corresponderse entre sí: la comparación profunda requiere una instantánea profunda para funcionar correctamente.</span><span class="sxs-lookup"><span data-stu-id="2167d-129">Note that the chosen comparison and snapshotting logic must correspond to each other: deep comparison requires deep snapshotting to function correctly.</span></span>

## <a name="simple-immutable-classes"></a><span data-ttu-id="2167d-130">Clases inmutables simples</span><span class="sxs-lookup"><span data-stu-id="2167d-130">Simple immutable classes</span></span>

<span data-ttu-id="2167d-131">Considere una propiedad que utiliza un convertidor de valores para asignar una clase simple e inmutable.</span><span class="sxs-lookup"><span data-stu-id="2167d-131">Consider a property that uses a value converter to map a simple, immutable class.</span></span>

[!code-csharp[SimpleImmutableClass](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=SimpleImmutableClass)]

[!code-csharp[ConfigureImmutableClassProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=ConfigureImmutableClassProperty)]

<span data-ttu-id="2167d-132">Las propiedades de este tipo no necesitan comparaciones especiales ni instantáneas porque:</span><span class="sxs-lookup"><span data-stu-id="2167d-132">Properties of this type do not need special comparisons or snapshots because:</span></span>

* <span data-ttu-id="2167d-133">La igualdad se invalida para que las distintas instancias se comparen correctamente</span><span class="sxs-lookup"><span data-stu-id="2167d-133">Equality is overridden so that different instances will compare correctly</span></span>
* <span data-ttu-id="2167d-134">El tipo es inmutable, por lo que no existe la posibilidad de alterar un valor de instantánea</span><span class="sxs-lookup"><span data-stu-id="2167d-134">The type is immutable, so there is no chance of mutating a snapshot value</span></span>

<span data-ttu-id="2167d-135">Por lo tanto, en este caso, el comportamiento predeterminado de EF Core es correcto.</span><span class="sxs-lookup"><span data-stu-id="2167d-135">So in this case the default behavior of EF Core is fine as it is.</span></span>

## <a name="simple-immutable-structs"></a><span data-ttu-id="2167d-136">Structs inmutables simples</span><span class="sxs-lookup"><span data-stu-id="2167d-136">Simple immutable structs</span></span>

<span data-ttu-id="2167d-137">La asignación para Structs simples también es sencilla y no requiere comparaciones o instantáneas especiales.</span><span class="sxs-lookup"><span data-stu-id="2167d-137">The mapping for simple structs is also simple and requires no special comparers or snapshotting.</span></span>

[!code-csharp[SimpleImmutableStruct](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=SimpleImmutableStruct)]

[!code-csharp[ConfigureImmutableStructProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=ConfigureImmutableStructProperty)]

<span data-ttu-id="2167d-138">EF Core tiene compatibilidad integrada para generar comparaciones compiladas miembro a miembro de propiedades de struct.</span><span class="sxs-lookup"><span data-stu-id="2167d-138">EF Core has built-in support for generating compiled, memberwise comparisons of struct properties.</span></span> <span data-ttu-id="2167d-139">Esto significa que no es necesario que los Structs tengan una igualdad invalidada para EF Core, pero todavía puede optar por [otras razones](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type).</span><span class="sxs-lookup"><span data-stu-id="2167d-139">This means structs don't need to have equality overridden for EF Core, but you may still choose to do this for [other reasons](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type).</span></span> <span data-ttu-id="2167d-140">Además, no es necesario realizar una instantánea especial, ya que las estructuras son inmutables y siempre se copian de miembro a miembro.</span><span class="sxs-lookup"><span data-stu-id="2167d-140">Also, special snapshotting is not needed since structs are immutable and are always copied memberwise anyway.</span></span> <span data-ttu-id="2167d-141">(Esto también se aplica a las estructuras mutables, pero las [estructuras mutables deberían evitarse en general](/dotnet/csharp/write-safe-efficient-code)).</span><span class="sxs-lookup"><span data-stu-id="2167d-141">(This is also true for mutable structs, but [mutable structs should in general be avoided](/dotnet/csharp/write-safe-efficient-code).)</span></span>

## <a name="mutable-classes"></a><span data-ttu-id="2167d-142">Clases mutables</span><span class="sxs-lookup"><span data-stu-id="2167d-142">Mutable classes</span></span>

<span data-ttu-id="2167d-143">Se recomienda usar tipos inmutables (clases o Structs) con convertidores de valores siempre que sea posible.</span><span class="sxs-lookup"><span data-stu-id="2167d-143">It is recommended that you use immutable types (classes or structs) with value converters when possible.</span></span> <span data-ttu-id="2167d-144">Esto suele ser más eficaz y tiene una semántica más clara que el uso de un tipo mutable.</span><span class="sxs-lookup"><span data-stu-id="2167d-144">This is usually more efficient and has cleaner semantics than using a mutable type.</span></span> <span data-ttu-id="2167d-145">Sin embargo, es habitual usar las propiedades de los tipos que la aplicación no puede cambiar.</span><span class="sxs-lookup"><span data-stu-id="2167d-145">However, that being said, it is common to use properties of types that the application cannot change.</span></span> <span data-ttu-id="2167d-146">Por ejemplo, asignar una propiedad que contenga una lista de números:</span><span class="sxs-lookup"><span data-stu-id="2167d-146">For example, mapping a property containing a list of numbers:</span></span>

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ListProperty)]

<span data-ttu-id="2167d-147">La clase <xref:System.Collections.Generic.List%601>:</span><span class="sxs-lookup"><span data-stu-id="2167d-147">The <xref:System.Collections.Generic.List%601> class:</span></span>

* <span data-ttu-id="2167d-148">Tiene igualdad de referencia; dos listas que contienen los mismos valores se tratan como diferentes.</span><span class="sxs-lookup"><span data-stu-id="2167d-148">Has reference equality; two lists containing the same values are treated as different.</span></span>
* <span data-ttu-id="2167d-149">Es mutable; los valores de la lista se pueden agregar y quitar.</span><span class="sxs-lookup"><span data-stu-id="2167d-149">Is mutable; values in the list can be added and removed.</span></span>

<span data-ttu-id="2167d-150">Una conversión de valor típica en una propiedad de lista puede convertir la lista a y desde JSON:</span><span class="sxs-lookup"><span data-stu-id="2167d-150">A typical value conversion on a list property might convert the list to and from JSON:</span></span>

### <a name="ef-core-50"></a>[<span data-ttu-id="2167d-151">EF Core 5.0</span><span class="sxs-lookup"><span data-stu-id="2167d-151">EF Core 5.0</span></span>](#tab/ef5)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty&highlight=7-10)]

### <a name="older-versions"></a>[<span data-ttu-id="2167d-152">Versiones anteriores</span><span class="sxs-lookup"><span data-stu-id="2167d-152">Older versions</span></span>](#tab/older-versions)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListPropertyOld.cs?name=ConfigureListProperty&highlight=8-11,17)]

***

<span data-ttu-id="2167d-153">El <xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601> constructor acepta tres expresiones:</span><span class="sxs-lookup"><span data-stu-id="2167d-153">The <xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601> constructor accepts three expressions:</span></span>

* <span data-ttu-id="2167d-154">Expresión para comprobar la igualdad</span><span class="sxs-lookup"><span data-stu-id="2167d-154">An expression for checking equality</span></span>
* <span data-ttu-id="2167d-155">Expresión para generar un código hash.</span><span class="sxs-lookup"><span data-stu-id="2167d-155">An expression for generating a hash code</span></span>
* <span data-ttu-id="2167d-156">Una expresión para la instantánea de un valor</span><span class="sxs-lookup"><span data-stu-id="2167d-156">An expression to snapshot a value</span></span>

<span data-ttu-id="2167d-157">En este caso, la comparación se realiza comprobando si las secuencias de números son iguales.</span><span class="sxs-lookup"><span data-stu-id="2167d-157">In this case the comparison is done by checking if the sequences of numbers are the same.</span></span>

<span data-ttu-id="2167d-158">Del mismo modo, el código hash se genera a partir de esta misma secuencia.</span><span class="sxs-lookup"><span data-stu-id="2167d-158">Likewise, the hash code is built from this same sequence.</span></span> <span data-ttu-id="2167d-159">(Tenga en cuenta que se trata de un código hash sobre valores mutables y, por lo tanto, puede [causar problemas](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/).</span><span class="sxs-lookup"><span data-stu-id="2167d-159">(Note that this is a hash code over mutable values and hence can [cause problems](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/).</span></span> <span data-ttu-id="2167d-160">En su lugar, puede ser inmutable si es posible).</span><span class="sxs-lookup"><span data-stu-id="2167d-160">Be immutable instead if you can.)</span></span>

<span data-ttu-id="2167d-161">La instantánea se crea mediante la clonación de la lista con `ToList` .</span><span class="sxs-lookup"><span data-stu-id="2167d-161">The snapshot is created by cloning the list with `ToList`.</span></span> <span data-ttu-id="2167d-162">De nuevo, esto solo es necesario si se van a mutar las listas.</span><span class="sxs-lookup"><span data-stu-id="2167d-162">Again, this is only needed if the lists are going to be mutated.</span></span> <span data-ttu-id="2167d-163">En su lugar, puede ser inmutable si es posible.</span><span class="sxs-lookup"><span data-stu-id="2167d-163">Be immutable instead if you can.</span></span>

> [!NOTE]
> <span data-ttu-id="2167d-164">Los convertidores de valores y los comparadores se construyen mediante expresiones en lugar de delegados simples.</span><span class="sxs-lookup"><span data-stu-id="2167d-164">Value converters and comparers are constructed using expressions rather than simple delegates.</span></span> <span data-ttu-id="2167d-165">Esto se debe a que EF Core inserta estas expresiones en un árbol de expresión mucho más complejo que se compila en un delegado de forma de entidad.</span><span class="sxs-lookup"><span data-stu-id="2167d-165">This is because EF Core inserts these expressions into a much more complex expression tree that is then compiled into an entity shaper delegate.</span></span> <span data-ttu-id="2167d-166">Conceptualmente, esto es similar a la inserción del compilador.</span><span class="sxs-lookup"><span data-stu-id="2167d-166">Conceptually, this is similar to compiler inlining.</span></span> <span data-ttu-id="2167d-167">Por ejemplo, una conversión simple solo puede ser una compilada en la conversión, en lugar de una llamada a otro método para realizar la conversión.</span><span class="sxs-lookup"><span data-stu-id="2167d-167">For example, a simple conversion may just be a compiled in cast, rather than a call to another method to do the conversion.</span></span>

## <a name="key-comparers"></a><span data-ttu-id="2167d-168">Comparadores de claves</span><span class="sxs-lookup"><span data-stu-id="2167d-168">Key comparers</span></span>

<span data-ttu-id="2167d-169">En la sección de fondo se explica por qué las comparaciones de claves pueden requerir una semántica especial.</span><span class="sxs-lookup"><span data-stu-id="2167d-169">The background section covers why key comparisons may require special semantics.</span></span> <span data-ttu-id="2167d-170">Asegúrese de crear un comparador que sea adecuado para las claves al establecerlo en una propiedad principal, principal o de clave externa.</span><span class="sxs-lookup"><span data-stu-id="2167d-170">Make sure to create a comparer that is appropriate for keys when setting it on a primary, principal, or foreign key property.</span></span>

<span data-ttu-id="2167d-171">Use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> en los casos poco frecuentes en los que se requiere una semántica diferente en la misma propiedad.</span><span class="sxs-lookup"><span data-stu-id="2167d-171">Use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> in the rare cases where different semantics is required on the same property.</span></span>

> [!NOTE]
> <span data-ttu-id="2167d-172"><xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetStructuralValueComparer%2A> se ha quedado obsoleto en EF Core 5,0.</span><span class="sxs-lookup"><span data-stu-id="2167d-172"><xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetStructuralValueComparer%2A> has been obsoleted in EF Core 5.0.</span></span> <span data-ttu-id="2167d-173">En su lugar, use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A>.</span><span class="sxs-lookup"><span data-stu-id="2167d-173">Use <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> instead.</span></span>

## <a name="overriding-the-default-comparer"></a><span data-ttu-id="2167d-174">Reemplazar el comparador predeterminado</span><span class="sxs-lookup"><span data-stu-id="2167d-174">Overriding the default comparer</span></span>

<span data-ttu-id="2167d-175">En ocasiones, es posible que la comparación predeterminada usada por EF Core no sea adecuada.</span><span class="sxs-lookup"><span data-stu-id="2167d-175">Sometimes the default comparison used by EF Core may not be appropriate.</span></span> <span data-ttu-id="2167d-176">Por ejemplo, la mutación de matrices de bytes no se detecta, de forma predeterminada, en EF Core.</span><span class="sxs-lookup"><span data-stu-id="2167d-176">For example, mutation of byte arrays is not, by default, detected in EF Core.</span></span> <span data-ttu-id="2167d-177">Esto se puede invalidar si se establece un comparador diferente en la propiedad:</span><span class="sxs-lookup"><span data-stu-id="2167d-177">This can be overridden by setting a different comparer on the property:</span></span>

[!code-csharp[OverrideComparer](../../../samples/core/Modeling/ValueConversions/OverridingByteArrayComparisons.cs?name=OverrideComparer)]

<span data-ttu-id="2167d-178">EF Core ahora comparará las secuencias de bytes y, por tanto, detectará las mutaciones de matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="2167d-178">EF Core will now compare byte sequences and will therefore detect byte array mutations.</span></span>
