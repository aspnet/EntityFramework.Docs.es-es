---
title: 'Consultas eficientes: EF Core'
description: Guía de rendimiento para consultas eficaces con Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e945a1e0f734d62ce8948904bcbe819455fcbefa
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128490"
---
# <a name="efficient-querying"></a><span data-ttu-id="bbb3f-103">Consultas eficaces</span><span class="sxs-lookup"><span data-stu-id="bbb3f-103">Efficient Querying</span></span>

<span data-ttu-id="bbb3f-104">Realizar consultas de forma eficaz es un gran asunto, que abarca temas como índices, estrategias de carga de entidades relacionadas y muchas otras.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="bbb3f-105">En esta sección se detallan algunos temas comunes para agilizar las consultas y los problemas que suelen tener los usuarios.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="bbb3f-106">Usar índices correctamente</span><span class="sxs-lookup"><span data-stu-id="bbb3f-106">Use indexes properly</span></span>

<span data-ttu-id="bbb3f-107">La principal decisión sobre si una consulta se ejecuta con rapidez o no es si se utilizarán correctamente los índices cuando sea apropiado: las bases de datos se utilizan normalmente para almacenar grandes cantidades de datos y las consultas que atraviesan tablas enteras suelen ser orígenes de graves problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="bbb3f-108">No es fácil detectar los problemas de indexación, ya que no es evidente de inmediato si una consulta determinada va a utilizar un índice o no.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="bbb3f-109">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="bbb3f-110">Una buena manera de detectar problemas de indexación consiste en localizar primero una consulta lenta y, a continuación, examinar su plan de consulta a través de la herramienta favorita de la base de datos. Consulte la página de [diagnóstico de rendimiento](xref:core/performance/performance-diagnosis) para obtener más información sobre cómo hacerlo.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="bbb3f-111">El plan de consulta muestra si la consulta atraviesa toda la tabla o utiliza un índice.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="bbb3f-112">Como norma general, no hay ningún conocimiento especial de EF para usar índices ni para diagnosticar problemas de rendimiento relacionados con ellos. los conocimientos generales de base de datos relacionados con los índices son tan relevantes para las aplicaciones EF como en las aplicaciones que no usan EF.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="bbb3f-113">A continuación se enumeran algunas directrices generales que se deben tener en cuenta al usar índices:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="bbb3f-114">Aunque los índices agilizan las consultas, también ralentizan las actualizaciones, ya que deben mantenerse actualizadas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="bbb3f-115">Evite definir índices que no sean necesarios y considere la posibilidad de usar [filtros de índice](xref:core/modeling/indexes#index-filter) para limitar el índice a un subconjunto de las filas, lo que reduce esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="bbb3f-116">Los índices compuestos pueden acelerar las consultas que filtran varias columnas, pero también pueden acelerar las consultas que no filtran en todas las columnas del índice, en función de la ordenación.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="bbb3f-117">Por ejemplo, un índice en las columnas A y B acelera las consultas que filtra a y B, así como las consultas que solo se filtran por, pero no acelera el filtrado de consultas solo por B.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="bbb3f-118">Si una consulta filtra por una expresión sobre una columna (por ejemplo `price / 2` ,), no se puede usar un índice simple.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="bbb3f-119">Sin embargo, puede definir una [columna persistente almacenada](xref:core/modeling/generated-properties#computed-columns) para la expresión y crear un índice sobre ella.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="bbb3f-120">Algunas bases de datos también admiten índices de expresión, que se pueden usar directamente para acelerar las consultas que filtran cualquier expresión.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="bbb3f-121">Las distintas bases de datos permiten configurar los índices de varias maneras y, en muchos casos EF Core proveedores los exponen a través de la API fluida.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="bbb3f-122">Por ejemplo, el proveedor de SQL Server le permite configurar si un índice está [agrupado](xref:core/providers/sql-server/indexes#clustering)o establecer su [factor de relleno](xref:core/providers/sql-server/indexes#fill-factor).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="bbb3f-123">Consulte la documentación del proveedor para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="bbb3f-124">Solo las propiedades necesarias del proyecto</span><span class="sxs-lookup"><span data-stu-id="bbb3f-124">Project only properties you need</span></span>

<span data-ttu-id="bbb3f-125">EF Core hace que sea muy fácil consultar las instancias de la entidad y, a continuación, usar esas instancias en el código.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="bbb3f-126">Sin embargo, la consulta de instancias de entidad puede extraer con frecuencia más datos de los necesarios en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="bbb3f-127">Tenga en cuenta lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="bbb3f-128">Aunque este código solo necesita realmente la propiedad de cada blog `Url` , se captura toda la entidad de blog y las columnas innecesarias se transfieren de la base de datos:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="bbb3f-129">Esto se puede optimizar mediante el uso `Select` de para indicar a EF Qué columnas se deben proyectar:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="bbb3f-130">El SQL resultante extrae solo las columnas necesarias:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="bbb3f-131">Si necesita proyectar más de una columna, salga de un tipo anónimo de C# con las propiedades que desee.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="bbb3f-132">Tenga en cuenta que esta técnica es muy útil para las consultas de solo lectura, pero las cosas son más complicadas si necesita *Actualizar* los blogs capturados, ya que el seguimiento de cambios de EF solo funciona con instancias de entidad.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="bbb3f-133">Es posible realizar actualizaciones sin cargar entidades enteras adjuntando una instancia de blog modificada e indicando a EF qué propiedades han cambiado, pero es una técnica más avanzada que puede no merecer la pena.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="bbb3f-134">Limitar el tamaño del conjunto de resultados</span><span class="sxs-lookup"><span data-stu-id="bbb3f-134">Limit the resultset size</span></span>

<span data-ttu-id="bbb3f-135">De forma predeterminada, una consulta devuelve todas las filas que coincidan con sus filtros:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="bbb3f-136">Dado que el número de filas devueltas depende de los datos reales de la base de datos, es imposible saber cuántos datos se cargarán desde la base de datos, cuánta memoria ocuparán los resultados y cuánta carga adicional se generará al procesar estos resultados (por ejemplo, enviándolos a un explorador del usuario a través de la red).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="bbb3f-137">En realidad, las bases de datos de prueba suelen contener poca información, por lo que todo funciona bien durante las pruebas, pero los problemas de rendimiento aparecen repentinamente cuando la consulta comienza a ejecutarse en datos reales y se devuelven muchas filas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="bbb3f-138">Como resultado, normalmente merece la pena pensar en limitar el número de resultados:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="bbb3f-139">Como mínimo, la interfaz de usuario podría mostrar un mensaje que indica que pueden existir más filas en la base de datos (y permitir que se recuperen de alguna otra manera).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="bbb3f-140">Una solución completa implementaría la *paginación*, donde la interfaz de usuario solo muestra un número determinado de filas a la vez y permite a los usuarios avanzar a la siguiente página según sea necesario. Normalmente, esto combina <xref:System.Linq.Enumerable.Take%2A> los <xref:System.Linq.Enumerable.Skip%2A> operadores y para seleccionar un intervalo específico en el conjunto de resultados cada vez.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="bbb3f-141">Evitar la explosión cartesiano al cargar entidades relacionadas</span><span class="sxs-lookup"><span data-stu-id="bbb3f-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="bbb3f-142">En las bases de datos relacionales, todas las entidades relacionadas se cargan mediante la introducción de instrucciones JOIN en consultas únicas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="bbb3f-143">Si un blog típico tiene varias entradas relacionadas, las filas de estas entradas duplicarán la información del blog,</span><span class="sxs-lookup"><span data-stu-id="bbb3f-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="bbb3f-144">lo que genera un problema conocido como "explosión cartesiana".</span><span class="sxs-lookup"><span data-stu-id="bbb3f-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="bbb3f-145">A medida que se cargan más relaciones uno a varios, la cantidad de datos duplicados puede crecer y afectar negativamente al rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="bbb3f-146">EF permite evitar este efecto mediante el uso de "consultas divididas", que cargan las entidades relacionadas a través de consultas independientes.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="bbb3f-147">Para obtener más información, lea [la documentación sobre consultas divididas y únicas](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="bbb3f-148">La implementación actual de [consultas divididas](xref:core/querying/single-split-queries) ejecuta un viaje de ida y vuelta para cada consulta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="bbb3f-149">Tenemos previsto mejorar esto en el futuro y ejecutar todas las consultas en un solo viaje de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="bbb3f-150">Cargar las entidades relacionadas concienzudamente cuando sea posible</span><span class="sxs-lookup"><span data-stu-id="bbb3f-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="bbb3f-151">Se recomienda leer [la página dedicada en entidades relacionadas](xref:core/querying/related-data) antes de continuar con esta sección.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="bbb3f-152">Cuando se trabaja con entidades relacionadas, normalmente sabemos de antemano lo que necesitamos cargar: un ejemplo típico sería la carga de un determinado conjunto de blogs, junto con todas sus publicaciones.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="bbb3f-153">En estos escenarios, siempre es mejor usar la [carga diligente](xref:core/querying/related-data/eager), de modo que EF pueda capturar todos los datos necesarios en un viaje de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="bbb3f-154">La característica de [inclusión filtrada](xref:core/querying/related-data/eager#filtered-include) , introducida en EF Core 5,0, también le permite limitar las entidades relacionadas que le gustaría cargar, manteniendo el proceso de carga diligente y, por lo tanto, factible en un único viaje de ida y vuelta:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="bbb3f-155">En otros escenarios, es posible que no sepa qué entidad relacionada vamos a necesitar antes de obtener su entidad principal.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="bbb3f-156">Por ejemplo, al cargar un blog, es posible que necesitemos consultar algún otro origen de datos, posiblemente un servicio WebService, para saber si estamos interesados en las publicaciones de ese blog.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="bbb3f-157">En estos casos, la carga [explícita](xref:core/querying/related-data/explicit) o [diferida](xref:core/querying/related-data/lazy) se puede usar para capturar entidades relacionadas por separado y rellenar la navegación de entradas del blog.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="bbb3f-158">Tenga en cuenta que, dado que estos métodos no son diligentes, requieren viajes de ida y vuelta adicionales a la base de datos, que es el origen de la ralentización. en función de su escenario específico, puede ser más eficaz cargar siempre todas las publicaciones, en lugar de ejecutar los viajes de ida adicionales y obtener de forma selectiva solo las publicaciones que necesite.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="bbb3f-159">Tenga cuidado con la carga diferida</span><span class="sxs-lookup"><span data-stu-id="bbb3f-159">Beware of lazy loading</span></span>

<span data-ttu-id="bbb3f-160">La [carga diferida](xref:core/querying/related-data/lazy) suele parecer una manera muy útil de escribir la lógica de base de datos, ya que EF Core carga automáticamente las entidades relacionadas de la base de datos, ya que el código tiene acceso a ellas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="bbb3f-161">Esto evita la carga de entidades relacionadas que no son necesarias (como la [carga explícita](xref:core/querying/related-data/explicit)) y, aparentemente, libera al programador de tener que tratar las entidades relacionadas de forma conjunta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="bbb3f-162">Sin embargo, la carga diferida es especialmente propensa para producir viajes de ida y vuelta innecesarios, lo que puede ralentizar la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="bbb3f-163">Tenga en cuenta lo siguiente.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="bbb3f-164">Este fragmento de código aparentemente inocente recorre en iteración todos los blogs y sus publicaciones, para imprimirlos. La activación del [registro de instrucciones](xref:core/logging-events-diagnostics/index) de EF Core revela lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="bbb3f-165">¿Qué ocurre aquí?</span><span class="sxs-lookup"><span data-stu-id="bbb3f-165">What's going on here?</span></span> <span data-ttu-id="bbb3f-166">¿Por qué se envían todas estas consultas para los bucles simples anteriores?</span><span class="sxs-lookup"><span data-stu-id="bbb3f-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="bbb3f-167">Con la carga diferida, las publicaciones de un blog solo se cargan (de forma diferida) cuando se tiene acceso a su propiedad posts. como resultado, cada iteración de la instrucción foreach interna desencadena una consulta de base de datos adicional, en su propio recorrido de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="bbb3f-168">Como resultado, después de que la consulta inicial cargue todos los blogs, tendrá otra consulta *por cada blog* y cargará todas sus entradas; a veces, esto se denomina el problema *N + 1* y puede causar problemas de rendimiento muy significativos.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="bbb3f-169">Suponiendo que vamos a necesitar todas las publicaciones de blogs, tiene sentido usar la carga diligente aquí en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="bbb3f-170">Se puede usar el operador [include](xref:core/querying/related-data/eager#eager-loading) para realizar la carga, pero como solo se necesitan las direcciones URL de los blogs (y solo se deben [cargar los elementos necesarios](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span></span> <span data-ttu-id="bbb3f-171">En su lugar, usaremos una proyección:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="bbb3f-172">Esto hará que EF Core Capture todos los blogs, junto con sus posts, en una sola consulta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="bbb3f-173">En algunos casos, también puede resultar útil evitar efectos de explosión cartesiano mediante el uso de [consultas divididas](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="bbb3f-174">Dado que la carga diferida facilita enormemente el desencadenamiento del problema N + 1, se recomienda evitarlo.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="bbb3f-175">La carga diligente o explícita la hacen muy claras en el código fuente cuando se produce un viaje de base de datos.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="bbb3f-176">Almacenamiento en búfer y transmisión por secuencias</span><span class="sxs-lookup"><span data-stu-id="bbb3f-176">Buffering and streaming</span></span>

<span data-ttu-id="bbb3f-177">El almacenamiento en búfer hace referencia a la carga de todos los resultados de la consulta en la memoria, mientras que el streaming significa que EF trata a la aplicación como un resultado único cada vez, nunca con el conjunto de resultados completo en la memoria.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-177">Buffering refers to loading all your query results into memory, whereas streaming means that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="bbb3f-178">En principio, los requisitos de memoria de una consulta de streaming son fijos, es decir, si la consulta devuelve 1 fila o 1000; por otro lado, una consulta de almacenamiento en búfer requiere más memoria para devolver más filas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="bbb3f-179">En el caso de las consultas que generan conjuntos de resultados grandes, puede ser un factor de rendimiento importante.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="bbb3f-180">El hecho de que un búfer de consulta o secuencias dependa de cómo se evalúa:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="bbb3f-181">Si las consultas devuelven solo unos cuantos resultados, probablemente no tenga que preocuparse de ello.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="bbb3f-182">Sin embargo, si la consulta puede devolver un gran número de filas, merece la pena hacer streaming en lugar de almacenar en búfer.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="bbb3f-183">Evite el uso de <xref:System.Linq.Enumerable.ToList%2A> o <xref:System.Linq.Enumerable.ToArray%2A> si piensa usar otro operador LINQ en el resultado; de esta forma, se almacenarán todos los resultados en la memoria.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="bbb3f-184">En su lugar, use <xref:System.Linq.Enumerable.AsEnumerable%2A>.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="bbb3f-185">Almacenamiento en búfer interno por EF</span><span class="sxs-lookup"><span data-stu-id="bbb3f-185">Internal buffering by EF</span></span>

<span data-ttu-id="bbb3f-186">En determinadas situaciones, EF almacenará en búfer el conjunto de resultados internamente, independientemente de cómo se evalúe la consulta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="bbb3f-187">Los dos casos en los que ocurre esto son:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="bbb3f-188">Cuando se implementa una estrategia de ejecución de reintento.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="bbb3f-189">Esto se hace para asegurarse de que se devuelven los mismos resultados si la consulta se vuelve a intentar más tarde.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="bbb3f-190">Cuando se usa la [consulta Split](xref:core/querying/single-split-queries) , se almacenan en búfer los conjuntos de filas de todas las consultas, excepto la última, a menos que se habilite MARS en SQL Server.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="bbb3f-191">Esto se debe a que normalmente no es posible tener varios conjuntos de consultas de consulta activos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="bbb3f-192">Tenga en cuenta que este almacenamiento en búfer interno se produce además de cualquier almacenamiento en búfer que se produzca mediante operadores LINQ.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="bbb3f-193">Por ejemplo, si se usa <xref:System.Linq.Enumerable.ToList%2A> en una consulta y se implementa una estrategia de ejecución de reintento, el conjunto de resultados se carga en la memoria *dos veces*: una vez internamente por EF y otra <xref:System.Linq.Enumerable.ToList%2A> .</span><span class="sxs-lookup"><span data-stu-id="bbb3f-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="bbb3f-194">Seguimiento, no seguimiento y resolución de identidad</span><span class="sxs-lookup"><span data-stu-id="bbb3f-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="bbb3f-195">Se recomienda leer [la página dedicada en el seguimiento y sin seguimiento](xref:core/querying/tracking) antes de continuar con esta sección.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="bbb3f-196">EF realiza un seguimiento de las instancias de la entidad de forma predeterminada, de modo que los cambios en ellas se detectan y se conservan cuando <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> se llama a.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="bbb3f-197">Otro efecto de las consultas de seguimiento es que EF detecta si ya se ha cargado una instancia de los datos y devolverá automáticamente la instancia de la que se ha realizado un seguimiento en lugar de devolver una nueva. Esto se denomina *resolución de identidad*.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="bbb3f-198">Desde la perspectiva del rendimiento, el seguimiento de cambios implica lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bbb3f-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="bbb3f-199">EF mantiene internamente un diccionario de instancias de las que se ha realizado un seguimiento.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="bbb3f-200">Cuando se cargan nuevos datos, EF comprueba el diccionario para ver si ya se ha realizado un seguimiento de una instancia para la clave de esa entidad (resolución de identidad).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="bbb3f-201">El mantenimiento y las búsquedas del diccionario tardan un tiempo en cargar los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="bbb3f-202">Antes de entregar una instancia cargada a la aplicación, EF realiza *instantáneas* de la instancia y mantiene la instantánea internamente.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="bbb3f-203">Cuando <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> se llama a, la instancia de la aplicación se compara con la instantánea para detectar los cambios que se van a conservar.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="bbb3f-204">La instantánea ocupa más memoria y el propio proceso de la instantánea lleva tiempo; a veces es posible especificar un comportamiento de la instantánea diferente, posiblemente más eficaz, a través de los [comparadores de valores](xref:core/modeling/value-comparers), o usar los proxies de seguimiento de cambios para omitir el proceso de la instantánea (aunque esto incluye su propio conjunto de desventajas).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="bbb3f-205">En los escenarios de solo lectura donde los cambios no se guardan en la base de datos, se pueden evitar las sobrecargas anteriores mediante el uso [de consultas sin seguimiento](xref:core/querying/tracking#no-tracking-queries).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="bbb3f-206">Sin embargo, puesto que las consultas sin seguimiento no realizan la resolución de identidad, una fila de base de datos a la que hacen referencia varias filas cargadas se materializará como una instancia diferente.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="bbb3f-207">Para ilustrar, supongamos que estamos cargando un gran número de publicaciones de la base de datos, así como el blog al que se hace referencia en cada publicación.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="bbb3f-208">Si se producen 100 publicaciones para hacer referencia al mismo blog, una consulta de seguimiento lo detecta a través de la resolución de identidades y todas las instancias de post hacen referencia a la misma instancia de blog desduplicada.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="bbb3f-209">Por el contrario, una consulta sin seguimiento duplica el mismo blog 100 veces y el código de aplicación debe escribirse en consecuencia.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="bbb3f-210">Estos son los resultados de una prueba comparativa que compara el seguimiento con el comportamiento sin seguimiento de una consulta que carga 10 blogs con 20 publicaciones cada una.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="bbb3f-211">[El código fuente está disponible aquí](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), no dude en usarlo como base para sus propias mediciones.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="bbb3f-212">Método</span><span class="sxs-lookup"><span data-stu-id="bbb3f-212">Method</span></span> | <span data-ttu-id="bbb3f-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="bbb3f-213">NumBlogs</span></span> | <span data-ttu-id="bbb3f-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="bbb3f-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="bbb3f-215">Media</span><span class="sxs-lookup"><span data-stu-id="bbb3f-215">Mean</span></span> |    <span data-ttu-id="bbb3f-216">Error</span><span class="sxs-lookup"><span data-stu-id="bbb3f-216">Error</span></span> |   <span data-ttu-id="bbb3f-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="bbb3f-217">StdDev</span></span> |     <span data-ttu-id="bbb3f-218">Mediana</span><span class="sxs-lookup"><span data-stu-id="bbb3f-218">Median</span></span> | <span data-ttu-id="bbb3f-219">Proporción</span><span class="sxs-lookup"><span data-stu-id="bbb3f-219">Ratio</span></span> | <span data-ttu-id="bbb3f-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="bbb3f-220">RatioSD</span></span> |   <span data-ttu-id="bbb3f-221">Gen. 0</span><span class="sxs-lookup"><span data-stu-id="bbb3f-221">Gen 0</span></span> |   <span data-ttu-id="bbb3f-222">Gen. 1</span><span class="sxs-lookup"><span data-stu-id="bbb3f-222">Gen 1</span></span> | <span data-ttu-id="bbb3f-223">Gen. 2</span><span class="sxs-lookup"><span data-stu-id="bbb3f-223">Gen 2</span></span> | <span data-ttu-id="bbb3f-224">Allocated</span><span class="sxs-lookup"><span data-stu-id="bbb3f-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="bbb3f-225">Realizar un seguimiento</span><span class="sxs-lookup"><span data-stu-id="bbb3f-225">AsTracking</span></span> |       <span data-ttu-id="bbb3f-226">10</span><span class="sxs-lookup"><span data-stu-id="bbb3f-226">10</span></span> |              <span data-ttu-id="bbb3f-227">20</span><span class="sxs-lookup"><span data-stu-id="bbb3f-227">20</span></span> | <span data-ttu-id="bbb3f-228">1.414,7 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-228">1,414.7 us</span></span> | <span data-ttu-id="bbb3f-229">27,20 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-229">27.20 us</span></span> | <span data-ttu-id="bbb3f-230">45,44 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-230">45.44 us</span></span> | <span data-ttu-id="bbb3f-231">1.405,5 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-231">1,405.5 us</span></span> |  <span data-ttu-id="bbb3f-232">1.00</span><span class="sxs-lookup"><span data-stu-id="bbb3f-232">1.00</span></span> |    <span data-ttu-id="bbb3f-233">0.00</span><span class="sxs-lookup"><span data-stu-id="bbb3f-233">0.00</span></span> | <span data-ttu-id="bbb3f-234">60,5469</span><span class="sxs-lookup"><span data-stu-id="bbb3f-234">60.5469</span></span> | <span data-ttu-id="bbb3f-235">13,6719</span><span class="sxs-lookup"><span data-stu-id="bbb3f-235">13.6719</span></span> |     - | <span data-ttu-id="bbb3f-236">380,11 KB</span><span class="sxs-lookup"><span data-stu-id="bbb3f-236">380.11 KB</span></span> |
| <span data-ttu-id="bbb3f-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="bbb3f-237">AsNoTracking</span></span> |       <span data-ttu-id="bbb3f-238">10</span><span class="sxs-lookup"><span data-stu-id="bbb3f-238">10</span></span> |              <span data-ttu-id="bbb3f-239">20</span><span class="sxs-lookup"><span data-stu-id="bbb3f-239">20</span></span> |   <span data-ttu-id="bbb3f-240">993,3 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-240">993.3 us</span></span> | <span data-ttu-id="bbb3f-241">24,04 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-241">24.04 us</span></span> | <span data-ttu-id="bbb3f-242">65,40 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-242">65.40 us</span></span> |   <span data-ttu-id="bbb3f-243">966,2 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-243">966.2 us</span></span> |  <span data-ttu-id="bbb3f-244">0.71</span><span class="sxs-lookup"><span data-stu-id="bbb3f-244">0.71</span></span> |    <span data-ttu-id="bbb3f-245">0,05</span><span class="sxs-lookup"><span data-stu-id="bbb3f-245">0.05</span></span> | <span data-ttu-id="bbb3f-246">37,1094</span><span class="sxs-lookup"><span data-stu-id="bbb3f-246">37.1094</span></span> |  <span data-ttu-id="bbb3f-247">6,8359</span><span class="sxs-lookup"><span data-stu-id="bbb3f-247">6.8359</span></span> |     - | <span data-ttu-id="bbb3f-248">232,89 KB</span><span class="sxs-lookup"><span data-stu-id="bbb3f-248">232.89 KB</span></span> |

<span data-ttu-id="bbb3f-249">Por último, es posible realizar actualizaciones sin la sobrecarga que supone el seguimiento de cambios, ya que se usa una consulta sin seguimiento y, después, se asocia la instancia devuelta al contexto, lo que especifica los cambios que se van a realizar.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="bbb3f-250">Esto transfiere la carga del seguimiento de cambios de EF al usuario y solo debe intentarse si se ha demostrado que la sobrecarga del seguimiento de cambios es inaceptable a través de la generación de perfiles o la prueba comparativa.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="bbb3f-251">Uso de SQL sin formato</span><span class="sxs-lookup"><span data-stu-id="bbb3f-251">Using raw SQL</span></span>

<span data-ttu-id="bbb3f-252">En algunos casos, existe un SQL más optimizado para la consulta, que EF no genera.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="bbb3f-253">Esto puede ocurrir cuando la construcción de SQL es una extensión específica de la base de datos que no es compatible, o simplemente porque EF no se traduce todavía en él.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="bbb3f-254">En estos casos, escribir SQL a mano puede proporcionar un aumento considerable del rendimiento y EF admite varias maneras de hacerlo.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="bbb3f-255">Use SQL sin formato [directamente en la consulta](xref:core/querying/raw-sql), por ejemplo, a través de <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> .</span><span class="sxs-lookup"><span data-stu-id="bbb3f-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="bbb3f-256">EF incluso le permite componer sobre el SQL sin formato con consultas LINQ normales, lo que le permite expresar solo una parte de la consulta en SQL sin procesar.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="bbb3f-257">Esta es una buena técnica cuando el código SQL sin procesar solo debe usarse en una sola consulta en el código base.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="bbb3f-258">Definir una [función definida por el usuario](xref:core/querying/database-functions) (UDF) y, a continuación, llamarla desde las consultas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="bbb3f-259">Tenga en cuenta que, dado que 5,0, EF permite que las UDF devuelvan conjuntos de resultados completos, que se conocen como funciones con valores de tabla (TVF), y también permite asignar un `DbSet` a una función, lo que hace que tenga el aspecto de solo otra tabla.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="bbb3f-260">Defina una vista de base de datos y realice una consulta a partir de ella en las consultas.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="bbb3f-261">Tenga en cuenta que, a diferencia de las funciones, las vistas no pueden aceptar parámetros.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="bbb3f-262">SQL sin procesar generalmente debe usarse como último recurso, después de asegurarse de que EF no puede generar el SQL que desea y cuando el rendimiento es lo suficientemente importante para que la consulta determinada lo justifique.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="bbb3f-263">El uso de SQL sin procesar aporta importantes desventajas de mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="bbb3f-264">Programación asincrónica</span><span class="sxs-lookup"><span data-stu-id="bbb3f-264">Asynchronous programming</span></span>

<span data-ttu-id="bbb3f-265">Como norma general, para que la aplicación sea escalable, es importante usar siempre las API asincrónicas en lugar de una sincrónica (por ejemplo, <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> en lugar de <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> ).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="bbb3f-266">Las API sincrónicas bloquean el subproceso mientras dure la e/s de la base de datos, lo que aumenta la necesidad de subprocesos y el número de cambios de contexto de subprocesos que se deben producir.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="bbb3f-267">Para obtener más información, vea la página sobre [programación asincrónica](xref:core/miscellaneous/async).</span><span class="sxs-lookup"><span data-stu-id="bbb3f-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="bbb3f-268">Evite mezclar código sincrónico y asincrónico en la misma aplicación: es muy fácil desencadenar problemas sutiles de colapso de grupos de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="bbb3f-269">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="bbb3f-269">Additional resources</span></span>

<span data-ttu-id="bbb3f-270">Vea la [sección rendimiento](xref:core/querying/null-comparisons#writing-performant-queries) de la página de documentación de comparación nula para ver algunas prácticas recomendadas al comparar valores que aceptan valores NULL.</span><span class="sxs-lookup"><span data-stu-id="bbb3f-270">See the [performance section](xref:core/querying/null-comparisons#writing-performant-queries) of the null comparison documentation page for some best practices when comparing nullable values.</span></span>
