---
title: Temas de rendimiento avanzados
description: Temas de rendimiento avanzados para Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657771"
---
# <a name="advanced-performance-topics"></a><span data-ttu-id="633bf-103">Temas de rendimiento avanzados</span><span class="sxs-lookup"><span data-stu-id="633bf-103">Advanced Performance Topics</span></span>

## <a name="dbcontext-pooling"></a><span data-ttu-id="633bf-104">Agrupación de DbContext</span><span class="sxs-lookup"><span data-stu-id="633bf-104">DbContext pooling</span></span>

<span data-ttu-id="633bf-105">`AddDbContextPool` habilita la agrupación de `DbContext` instancias de.</span><span class="sxs-lookup"><span data-stu-id="633bf-105">`AddDbContextPool` enables pooling of `DbContext` instances.</span></span> <span data-ttu-id="633bf-106">La agrupación de contexto puede aumentar el rendimiento en escenarios de gran escala, como servidores Web, mediante la reutilización de instancias de contexto, en lugar de crear nuevas instancias para cada solicitud.</span><span class="sxs-lookup"><span data-stu-id="633bf-106">Context pooling can increase throughput in high-scale scenarios such as web servers by reusing context instances, rather than creating new instances for each request.</span></span>

<span data-ttu-id="633bf-107">El patrón típico en una aplicación ASP.NET Core con EF Core implica registrar un tipo personalizado en <xref:Microsoft.EntityFrameworkCore.DbContext> el contenedor de [inserción de dependencias](/aspnet/core/fundamentals/dependency-injection) y obtener instancias de ese tipo a través de parámetros de constructor en controladores o Razor pages.</span><span class="sxs-lookup"><span data-stu-id="633bf-107">The typical pattern in an ASP.NET Core app using EF Core involves registering a custom <xref:Microsoft.EntityFrameworkCore.DbContext> type into the [dependency injection](/aspnet/core/fundamentals/dependency-injection) container and obtaining instances of that type through constructor parameters in controllers or Razor Pages.</span></span> <span data-ttu-id="633bf-108">Mediante la inserción de constructores, se crea una nueva instancia de contexto para cada solicitud.</span><span class="sxs-lookup"><span data-stu-id="633bf-108">Using constructor injection, a new context instance is created for each request.</span></span>

<span data-ttu-id="633bf-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> habilita un grupo de instancias de contexto reutilizables.</span><span class="sxs-lookup"><span data-stu-id="633bf-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> enables a pool of reusable context instances.</span></span> <span data-ttu-id="633bf-110">Para usar la agrupación de contexto, use el `AddDbContextPool` método en lugar de `AddDbContext` durante el registro del servicio:</span><span class="sxs-lookup"><span data-stu-id="633bf-110">To use context pooling, use the `AddDbContextPool` method instead of `AddDbContext` during service registration:</span></span>

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

<span data-ttu-id="633bf-111">Cuando `AddDbContextPool` se usa, en el momento en que se solicita una instancia de contexto, EF comprueba primero si hay una instancia disponible en el grupo.</span><span class="sxs-lookup"><span data-stu-id="633bf-111">When `AddDbContextPool` is used, at the time a context instance is requested, EF first checks if there is an instance available in the pool.</span></span> <span data-ttu-id="633bf-112">Una vez que termina el procesamiento de la solicitud, se restablece cualquier estado en la instancia y la propia instancia se devuelve al grupo.</span><span class="sxs-lookup"><span data-stu-id="633bf-112">Once the request processing finalizes, any state on the instance is reset and the instance is itself returned to the pool.</span></span>

<span data-ttu-id="633bf-113">Esto es conceptualmente similar a la forma en que funciona la agrupación de conexiones en los proveedores de ADO.NET y tiene la ventaja de ahorrar parte del costo de inicialización de la instancia de contexto.</span><span class="sxs-lookup"><span data-stu-id="633bf-113">This is conceptually similar to how connection pooling operates in ADO.NET providers and has the advantage of saving some of the cost of initialization of the context instance.</span></span>

<span data-ttu-id="633bf-114">El `poolSize` parámetro de <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> establece el número máximo de instancias retenidas por el grupo.</span><span class="sxs-lookup"><span data-stu-id="633bf-114">The `poolSize` parameter of <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> sets the maximum number of instances retained by the pool.</span></span> <span data-ttu-id="633bf-115">Una vez que `poolSize` se supera, las nuevas instancias de contexto no se almacenan en caché y EF recurre al comportamiento de no agrupación de la creación de instancias a petición.</span><span class="sxs-lookup"><span data-stu-id="633bf-115">Once `poolSize` is exceeded, new context instances are not cached and  EF falls back to the non-pooling behavior of creating instances on demand.</span></span>

### <a name="limitations"></a><span data-ttu-id="633bf-116">Limitaciones</span><span class="sxs-lookup"><span data-stu-id="633bf-116">Limitations</span></span>

<span data-ttu-id="633bf-117">Se debe crear un perfiles de las aplicaciones y probarlas para mostrar que la inicialización del contexto supone un costo significativo.</span><span class="sxs-lookup"><span data-stu-id="633bf-117">Apps should be profiled and tested to show that context initialization is a significant cost.</span></span>

<span data-ttu-id="633bf-118">`AddDbContextPool` tiene algunas limitaciones en lo que se puede hacer en el `OnConfiguring` método del contexto.</span><span class="sxs-lookup"><span data-stu-id="633bf-118">`AddDbContextPool` has a few limitations on what can be done in the `OnConfiguring` method of the context.</span></span>

> [!WARNING]
> <span data-ttu-id="633bf-119">Evite el uso de la agrupación de contexto en aplicaciones que mantienen el estado.</span><span class="sxs-lookup"><span data-stu-id="633bf-119">Avoid using context pooling in apps that maintain state.</span></span> <span data-ttu-id="633bf-120">Por ejemplo, los campos privados en el contexto que no se deberían compartir entre las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="633bf-120">For example, private fields in the context that shouldn't be shared across requests.</span></span> <span data-ttu-id="633bf-121">EF Core solo restablece el estado que se conoce antes de agregar una instancia de contexto al grupo.</span><span class="sxs-lookup"><span data-stu-id="633bf-121">EF Core only resets the state that it is aware of before adding a context instance to the pool.</span></span>

<span data-ttu-id="633bf-122">La agrupación de contexto funciona mediante la reutilización de la misma instancia de contexto en todas las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="633bf-122">Context pooling works by reusing the same context instance across requests.</span></span> <span data-ttu-id="633bf-123">Esto significa que se registra de forma eficaz como [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) en lo que se refiere a la propia instancia para que pueda persistir.</span><span class="sxs-lookup"><span data-stu-id="633bf-123">This means that it's effectively registered as a [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in terms of the instance itself so that it's able to persist.</span></span>

<span data-ttu-id="633bf-124">La agrupación de contexto está pensada para escenarios en los que la configuración de contexto, que incluye los servicios resueltos, se fija entre solicitudes.</span><span class="sxs-lookup"><span data-stu-id="633bf-124">Context pooling is intended for scenarios where the context configuration, which includes services resolved, is fixed between requests.</span></span> <span data-ttu-id="633bf-125">En los casos en los que se requieren los servicios de [ámbito](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) o es necesario cambiar la configuración, no utilice la agrupación.</span><span class="sxs-lookup"><span data-stu-id="633bf-125">For cases where [Scoped](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) services are required, or configuration needs to be changed, don't use pooling.</span></span> <span data-ttu-id="633bf-126">La ganancia de rendimiento de la agrupación suele ser despreciable, excepto en escenarios muy optimizados.</span><span class="sxs-lookup"><span data-stu-id="633bf-126">The performance gain from pooling is usually negligible except in highly optimized scenarios.</span></span>

## <a name="query-caching-and-parameterization"></a><span data-ttu-id="633bf-127">Almacenamiento en caché y parametrización de consultas</span><span class="sxs-lookup"><span data-stu-id="633bf-127">Query caching and parameterization</span></span>

<span data-ttu-id="633bf-128">Cuando EF recibe un árbol de consulta LINQ para su ejecución, primero debe "compilar" ese árbol en una consulta SQL.</span><span class="sxs-lookup"><span data-stu-id="633bf-128">When EF receives a LINQ query tree for execution, it must first "compile" that tree into a SQL query.</span></span> <span data-ttu-id="633bf-129">Dado que se trata de un proceso intensivo, EF almacena en caché las consultas por la *forma* de árbol de consulta: las consultas con la misma estructura reutilizan las salidas de compilación almacenadas en caché internamente y pueden omitir la compilación repetida.</span><span class="sxs-lookup"><span data-stu-id="633bf-129">Because this is a heavy process, EF caches queries by the query tree *shape*: queries with the same structure reuse internally-cached compilation outputs, and can skip repeated compilation.</span></span> <span data-ttu-id="633bf-130">Las distintas consultas pueden seguir haciendo referencia a *valores* diferentes, pero siempre y cuando estos valores estén correctamente parametrizados, la estructura será la misma y el almacenamiento en caché funcionará correctamente.</span><span class="sxs-lookup"><span data-stu-id="633bf-130">The different queries may still reference different *values*, but as long as these values are properly parameterized, the structure is the same and caching will function properly.</span></span>

<span data-ttu-id="633bf-131">Tenga en cuenta las dos consultas siguientes:</span><span class="sxs-lookup"><span data-stu-id="633bf-131">Consider the following two queries:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

<span data-ttu-id="633bf-132">Dado que los árboles de expresión contienen constantes diferentes, el árbol de expresión difiere y cada una de estas consultas se compilará por separado mediante EF Core.</span><span class="sxs-lookup"><span data-stu-id="633bf-132">Since the expression trees contains different constants, the expression tree differs and each of these queries will be compiled separately by EF Core.</span></span> <span data-ttu-id="633bf-133">Además, cada consulta genera un comando SQL ligeramente diferente:</span><span class="sxs-lookup"><span data-stu-id="633bf-133">In addition, each query produces a slightly different SQL command:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

<span data-ttu-id="633bf-134">Dado que SQL es diferente, el servidor de base de datos probablemente también tendrá que generar un plan de consulta para ambas consultas, en lugar de reutilizar el mismo plan.</span><span class="sxs-lookup"><span data-stu-id="633bf-134">Because the SQL differs, your database server will likely also need to produce a query plan for both queries, rather than reusing the same plan.</span></span>

<span data-ttu-id="633bf-135">Una pequeña modificación en las consultas puede cambiar considerablemente:</span><span class="sxs-lookup"><span data-stu-id="633bf-135">A small modification to your queries can change things considerably:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

<span data-ttu-id="633bf-136">Dado que el nombre del blog ahora tiene *parámetros*, ambas consultas tienen la misma forma de árbol y EF solo debe compilarse una vez.</span><span class="sxs-lookup"><span data-stu-id="633bf-136">Since the blog name is now *parameterized*, both queries have the same tree shape, and EF only needs to be compiled once.</span></span> <span data-ttu-id="633bf-137">El SQL generado también tiene parámetros, lo que permite que la base de datos vuelva a usar el mismo plan de consulta:</span><span class="sxs-lookup"><span data-stu-id="633bf-137">The SQL produced is also parameterized, allowing the database to reuse the same query plan:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

<span data-ttu-id="633bf-138">Tenga en cuenta que no hay necesidad de parametrizar cada una de las consultas: es absolutamente preciso tener algunas consultas con constantes y, en realidad, las bases de datos (y EF) pueden realizar algunas tareas de optimización en torno a constantes que no son posibles cuando la consulta está parametrizada.</span><span class="sxs-lookup"><span data-stu-id="633bf-138">Note that there is no need to parameterize each and every query: it's perfectly fine to have some queries with constants, and indeed, databases (and EF) can sometimes perform certain optimization around constants which aren't possible when the query is parameterized.</span></span> <span data-ttu-id="633bf-139">Vea la sección sobre [consultas construidas dinámicamente](#dynamically-constructed-queries) para obtener un ejemplo en el que la parametrización adecuada es fundamental.</span><span class="sxs-lookup"><span data-stu-id="633bf-139">See the section on [dynamically-constructed queries](#dynamically-constructed-queries) for an example where proper parameterization is crucial.</span></span>

> [!NOTE]
> <span data-ttu-id="633bf-140">Los [contadores de eventos](xref:core/logging-events-diagnostics/event-counters) de EF Core notifican la tasa de aciertos de caché de consultas.</span><span class="sxs-lookup"><span data-stu-id="633bf-140">EF Core's [event counters](xref:core/logging-events-diagnostics/event-counters) report the Query Cache Hit Rate.</span></span> <span data-ttu-id="633bf-141">En una aplicación normal, este contador alcanza el 100% poco después del inicio del programa, una vez que la mayoría de las consultas se han ejecutado al menos una vez.</span><span class="sxs-lookup"><span data-stu-id="633bf-141">In a normal application, this counter reaches 100% soon after program startup, once most queries have executed at least once.</span></span> <span data-ttu-id="633bf-142">Si este contador permanece estable por debajo del 100%, es una indicación de que la aplicación puede estar haciendo algo que derrota a la caché de consultas. es una buena idea investigarlo.</span><span class="sxs-lookup"><span data-stu-id="633bf-142">If this counter remains stable below 100%, that is an indication that your application may be doing something which defeats the query cache - it's a good idea to investigate that.</span></span>

> [!NOTE]
> <span data-ttu-id="633bf-143">La forma en que la base de datos administra los planes de consulta depende de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="633bf-143">How the database manages caches query plans is database-dependent.</span></span> <span data-ttu-id="633bf-144">Por ejemplo, SQL Server mantiene implícitamente una memoria caché del plan de consulta LRU, mientras que PostgreSQL no (pero las instrucciones preparadas pueden producir un efecto final muy similar).</span><span class="sxs-lookup"><span data-stu-id="633bf-144">For example, SQL Server implicitly maintains an LRU query plan cache, whereas PostgreSQL does not (but prepared statements can produce a very similar end effect).</span></span> <span data-ttu-id="633bf-145">Consulte la documentación de la base de datos para obtener más detalles.</span><span class="sxs-lookup"><span data-stu-id="633bf-145">Consult your database documentation for more details.</span></span>

## <a name="dynamically-constructed-queries"></a><span data-ttu-id="633bf-146">Consultas construidas dinámicamente</span><span class="sxs-lookup"><span data-stu-id="633bf-146">Dynamically-constructed queries</span></span>

<span data-ttu-id="633bf-147">En algunas situaciones, es necesario crear dinámicamente las consultas LINQ en lugar de especificarlas de forma inadecuada en el código fuente.</span><span class="sxs-lookup"><span data-stu-id="633bf-147">In some situations, it is necessary to dynamically construct LINQ queries rather than specifying them outright in source code.</span></span> <span data-ttu-id="633bf-148">Esto puede ocurrir, por ejemplo, en un sitio web que recibe detalles de consulta arbitrarios de un cliente, con operadores de consulta abiertos (ordenación, filtrado, paginación...). En principio, si se realiza correctamente, las consultas construidas dinámicamente pueden ser tan eficaces como las normales (aunque no es posible usar la optimización de consultas compiladas con consultas dinámicas).</span><span class="sxs-lookup"><span data-stu-id="633bf-148">This can happen, for example, in a website which receives arbitrary query details from a client, with open-ended query operators (sorting, filtering, paging...). In principle, if done correctly, dynamically-constructed queries can be just as efficient as regular ones (although it's not possible to use the compiled query optimization with dynamic queries).</span></span> <span data-ttu-id="633bf-149">Sin embargo, en la práctica, suelen ser el origen de los problemas de rendimiento, ya que es fácil producir accidentalmente árboles de expresión con formas que difieren cada vez.</span><span class="sxs-lookup"><span data-stu-id="633bf-149">In practice, however, they are frequently the source of performance issues, since it's easy to accidentally produce expression trees with shapes that differ every time.</span></span>

<span data-ttu-id="633bf-150">En el ejemplo siguiente se usan dos técnicas para crear una consulta de forma dinámica: agregamos un `Where` operador a la consulta solo si el parámetro especificado no es NULL.</span><span class="sxs-lookup"><span data-stu-id="633bf-150">The following example uses two techniques to dynamically construct a query; we add a `Where` operator to the query only if the given parameter is not null.</span></span> <span data-ttu-id="633bf-151">Tenga en cuenta que no se trata de un buen caso de uso para la creación dinámica de una consulta, pero se usa para simplificar:</span><span class="sxs-lookup"><span data-stu-id="633bf-151">Note that this isn't a good use case for dynamically constructing a query - but we're using it for simplicity:</span></span>

### <a name="with-constant"></a>[<span data-ttu-id="633bf-152">Con constante</span><span class="sxs-lookup"><span data-stu-id="633bf-152">With constant</span></span>](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[<span data-ttu-id="633bf-153">With (parámetro)</span><span class="sxs-lookup"><span data-stu-id="633bf-153">With parameter</span></span>](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

<span data-ttu-id="633bf-154">Las pruebas comparativas de estas dos técnicas proporcionan los siguientes resultados:</span><span class="sxs-lookup"><span data-stu-id="633bf-154">Benchmarking these two techniques gives the following results:</span></span>

|        <span data-ttu-id="633bf-155">Método</span><span class="sxs-lookup"><span data-stu-id="633bf-155">Method</span></span> |       <span data-ttu-id="633bf-156">Media</span><span class="sxs-lookup"><span data-stu-id="633bf-156">Mean</span></span> |    <span data-ttu-id="633bf-157">Error</span><span class="sxs-lookup"><span data-stu-id="633bf-157">Error</span></span> |    <span data-ttu-id="633bf-158">StdDev</span><span class="sxs-lookup"><span data-stu-id="633bf-158">StdDev</span></span> |   <span data-ttu-id="633bf-159">Gen. 0</span><span class="sxs-lookup"><span data-stu-id="633bf-159">Gen 0</span></span> |  <span data-ttu-id="633bf-160">Gen. 1</span><span class="sxs-lookup"><span data-stu-id="633bf-160">Gen 1</span></span> | <span data-ttu-id="633bf-161">Gen. 2</span><span class="sxs-lookup"><span data-stu-id="633bf-161">Gen 2</span></span> | <span data-ttu-id="633bf-162">Allocated</span><span class="sxs-lookup"><span data-stu-id="633bf-162">Allocated</span></span> |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  <span data-ttu-id="633bf-163">WithConstant</span><span class="sxs-lookup"><span data-stu-id="633bf-163">WithConstant</span></span> | <span data-ttu-id="633bf-164">1.096,7 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-164">1,096.7 us</span></span> | <span data-ttu-id="633bf-165">12,54 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-165">12.54 us</span></span> |  <span data-ttu-id="633bf-166">11,12 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-166">11.12 us</span></span> | <span data-ttu-id="633bf-167">13,6719</span><span class="sxs-lookup"><span data-stu-id="633bf-167">13.6719</span></span> | <span data-ttu-id="633bf-168">1,9531</span><span class="sxs-lookup"><span data-stu-id="633bf-168">1.9531</span></span> |     - |  <span data-ttu-id="633bf-169">83,91 KB</span><span class="sxs-lookup"><span data-stu-id="633bf-169">83.91 KB</span></span> |
| <span data-ttu-id="633bf-170">WithParameter</span><span class="sxs-lookup"><span data-stu-id="633bf-170">WithParameter</span></span> |   <span data-ttu-id="633bf-171">570,8 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-171">570.8 us</span></span> | <span data-ttu-id="633bf-172">42,43 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-172">42.43 us</span></span> | <span data-ttu-id="633bf-173">124,43 EE. UU.</span><span class="sxs-lookup"><span data-stu-id="633bf-173">124.43 us</span></span> |  <span data-ttu-id="633bf-174">5,8594</span><span class="sxs-lookup"><span data-stu-id="633bf-174">5.8594</span></span> |      - |     - |  <span data-ttu-id="633bf-175">37,16 KB</span><span class="sxs-lookup"><span data-stu-id="633bf-175">37.16 KB</span></span> |

<span data-ttu-id="633bf-176">Aunque la diferencia de submilisegundos parezca pequeña, tenga en cuenta que la versión constante contamina continuamente la memoria caché y hace que se vuelvan a compilar otras consultas, lo que ralentiza también su funcionamiento.</span><span class="sxs-lookup"><span data-stu-id="633bf-176">Even if the sub-millisecond difference seems small, keep in mind that the constant version continuously pollutes the cache and causes other queries to be re-compiled, slowing them down as well.</span></span>

> [!NOTE]
> <span data-ttu-id="633bf-177">Evite construir consultas con la API de árbol de expresión a menos que realmente necesite.</span><span class="sxs-lookup"><span data-stu-id="633bf-177">Avoid constructing queries with the expression tree API unless you really need to.</span></span> <span data-ttu-id="633bf-178">Aparte de la complejidad de la API, es muy fácil producir involuntariamente problemas de rendimiento significativos al utilizarlos.</span><span class="sxs-lookup"><span data-stu-id="633bf-178">Aside from the API's complexity, it's very easy to inadvertently cause significant performance issues when using them.</span></span>
