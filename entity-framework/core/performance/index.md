---
title: 'Introducción al rendimiento: EF Core'
description: Guía de rendimiento para usar Entity Framework Core de forma eficaz
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657691"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="b4520-103">Introducción al rendimiento</span><span class="sxs-lookup"><span data-stu-id="b4520-103">Introduction to Performance</span></span>

<span data-ttu-id="b4520-104">El rendimiento de la base de datos es un tema amplio y complejo que abarca toda una pila de componentes: la base de datos, la red, el controlador de base de datos y los niveles de acceso a datos, como EF Core.</span><span class="sxs-lookup"><span data-stu-id="b4520-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="b4520-105">Aunque los niveles generales y los O/RM como EF Core simplifican considerablemente el desarrollo de aplicaciones y mejoran la facilidad de mantenimiento, en ocasiones pueden ser opacos y ocultar detalles internos críticos para el rendimiento, como el SQL que se ejecuta.</span><span class="sxs-lookup"><span data-stu-id="b4520-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="b4520-106">En esta sección se intenta proporcionar información general sobre cómo conseguir un buen rendimiento con EF Core y cómo evitar errores comunes que pueden degradar el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="b4520-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="b4520-107">Identificación de cuellos de botella y medidas continuadas</span><span class="sxs-lookup"><span data-stu-id="b4520-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="b4520-108">Como sucede siempre con el rendimiento, es importante no apresurarse en la optimización sin contar con datos que muestren un problema; como el gran Donald Knuth afirmó, "La optimización prematura es la raíz de todos los males".</span><span class="sxs-lookup"><span data-stu-id="b4520-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="b4520-109">En la sección de [diagnóstico del rendimiento](xref:core/performance/performance-diagnosis) se describen varias maneras de entender dónde dedica tiempo la aplicación en la lógica de base de datos y cómo identificar áreas problemáticas concretas.</span><span class="sxs-lookup"><span data-stu-id="b4520-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="b4520-110">Una vez que se ha identificado una consulta lenta, se pueden barajar las soluciones: ¿falta un índice en la base de datos?</span><span class="sxs-lookup"><span data-stu-id="b4520-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="b4520-111">¿Se deben probar otros modelos de consulta?</span><span class="sxs-lookup"><span data-stu-id="b4520-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="b4520-112">Siempre debe someter a un banco de pruebas el código y las posibles alternativas personalmente: la sección de diagnóstico del rendimiento contiene un banco de pruebas de ejemplo con BenchmarkDotNet, que puede usar como plantilla para pruebas comparativas propias.</span><span class="sxs-lookup"><span data-stu-id="b4520-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="b4520-113">No suponga que los bancos de pruebas públicos y generales se aplican tal cual a cada caso de uso concreto; una gran variedad de factores, como la latencia de la base de datos, la complejidad de las consultas y las cantidades de datos reales de las tablas, pueden tener un impacto profundo en la solución más adecuada.</span><span class="sxs-lookup"><span data-stu-id="b4520-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="b4520-114">Por ejemplo, muchos bancos de pruebas públicos se usan bajo condiciones de red idóneas, donde la latencia para la base de datos es casi cero y con consultas extremadamente ligeras que apenas requieren procesamiento (o E/S de disco) en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="b4520-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="b4520-115">Aunque son valiosos para comparar las sobrecargas en tiempo de ejecución de los diferentes niveles de acceso a datos, las diferencias que revelan suelen ser insignificantes en una aplicación real, donde la base de datos realiza el trabajo real y la latencia en la base de datos es un factor de rendimiento importante.</span><span class="sxs-lookup"><span data-stu-id="b4520-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="b4520-116">Aspectos del rendimiento de acceso a datos</span><span class="sxs-lookup"><span data-stu-id="b4520-116">Aspects of data access performance</span></span>

<span data-ttu-id="b4520-117">El rendimiento general del acceso a datos se puede dividir en las siguientes categorías generales:</span><span class="sxs-lookup"><span data-stu-id="b4520-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="b4520-118">**Rendimiento de base de datos puro**.</span><span class="sxs-lookup"><span data-stu-id="b4520-118">**Pure database performance**.</span></span> <span data-ttu-id="b4520-119">Con las bases de datos relacionales, EF traduce las consultas LINQ de la aplicación en las instrucciones SQL que ejecuta la base de datos; estas instrucciones SQL se pueden ejecutar de forma más o menos eficaz.</span><span class="sxs-lookup"><span data-stu-id="b4520-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="b4520-120">El índice adecuado en el lugar adecuado puede marcar considerablemente las diferencias para el rendimiento de SQL, o bien volver a escribir la consulta LINQ puede hacer que EF genere una consulta SQL mejor.</span><span class="sxs-lookup"><span data-stu-id="b4520-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="b4520-121">**Transferencia de datos entre redes**.</span><span class="sxs-lookup"><span data-stu-id="b4520-121">**Network data transfer**.</span></span> <span data-ttu-id="b4520-122">Como sucede con cualquier sistema de redes, es importante limitar la cantidad de datos que se transmiten por la conexión.</span><span class="sxs-lookup"><span data-stu-id="b4520-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="b4520-123">Esto implica asegurarse de que solo se envían y cargan los datos que se van a necesitar, pero que también se evita el efecto denominado "explosión cartesiana" al cargar entidades relacionadas.</span><span class="sxs-lookup"><span data-stu-id="b4520-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="b4520-124">**Recorridos de ida y vuelta de red**.</span><span class="sxs-lookup"><span data-stu-id="b4520-124">**Network roundtrips**.</span></span> <span data-ttu-id="b4520-125">Más allá de la cantidad de datos que se transmiten, los recorridos de ida y vuelta de red, ya que el tiempo que se tarda en ejecutar una consulta en la base de datos puede verse reducido por el tiempo de desplazamiento de los paquetes entre la aplicación y la base de datos.</span><span class="sxs-lookup"><span data-stu-id="b4520-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="b4520-126">La sobrecarga de los recorridos de ida y vuelta depende en gran medida del entorno; cuanto más lejos esté el servidor de base de datos, mayor será la latencia y más costoso cada recorrido de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="b4520-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="b4520-127">Con la llegada de la nube, las aplicaciones se encuentran cada vez más lejos de la base de datos y las más activas que realizan demasiados recorridos de ida y vuelta sufren un rendimiento degradado.</span><span class="sxs-lookup"><span data-stu-id="b4520-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="b4520-128">Por tanto, es importante comprender exactamente cuándo la aplicación se pone en contacto con la base de datos, cuántos recorridos de ida y vuelta realiza, y si ese número se puede minimizar.</span><span class="sxs-lookup"><span data-stu-id="b4520-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="b4520-129">**Sobrecarga de tiempo de ejecución de EF**.</span><span class="sxs-lookup"><span data-stu-id="b4520-129">**EF runtime overhead**.</span></span> <span data-ttu-id="b4520-130">Finalmente, EF agrega una sobrecarga en tiempo de ejecución a las operaciones de base de datos: EF debe compilar las consultas desde LINQ to SQL (aunque normalmente solo se debe hacer una vez), el seguimiento de los cambios agrega cierta sobrecarga (pero se puede deshabilitar), etc. En la práctica, es probable que la sobrecarga de EF para las aplicaciones reales sea insignificante en la mayoría de los casos, ya que el tiempo de ejecución de la consulta en la base de datos y la latencia de red dominan el tiempo total; pero es importante comprender cuáles son las opciones y cómo evitar algunos problemas.</span><span class="sxs-lookup"><span data-stu-id="b4520-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="b4520-131">Saber lo que ocurre en segundo plano</span><span class="sxs-lookup"><span data-stu-id="b4520-131">Know what's happening under the hood</span></span>

<span data-ttu-id="b4520-132">EF permite a los desarrolladores concentrarse en la lógica empresarial mediante la generación de SQL, la materialización de resultados y la realización de otras tareas.</span><span class="sxs-lookup"><span data-stu-id="b4520-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="b4520-133">Como sucede con cualquier nivel o abstracción, también tiende a ocultar lo que sucede en segundo plano, como las consultas SQL reales que se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="b4520-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="b4520-134">El rendimiento no es necesariamente un aspecto fundamental de todas las aplicaciones, sino que, en las aplicaciones en las que lo es, es imprescindible que el desarrollador comprenda lo que hace EF: inspeccionar las consultas SQL salientes, seguir los recorridos de ida y vuelta para asegurarse de que el problema N+1 no se produzca, etc.</span><span class="sxs-lookup"><span data-stu-id="b4520-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="b4520-135">Almacenamiento en caché fuera de la base de datos</span><span class="sxs-lookup"><span data-stu-id="b4520-135">Cache outside the database</span></span>

<span data-ttu-id="b4520-136">Por último, la manera más eficaz de interactuar con una base de datos es no interactuar con ella.</span><span class="sxs-lookup"><span data-stu-id="b4520-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="b4520-137">Es decir, si el acceso a la base de datos aparece como un cuello de botella de rendimiento en la aplicación, puede merecer la pena almacenar en caché determinados resultados fuera de la base de datos, para minimizar las solicitudes.</span><span class="sxs-lookup"><span data-stu-id="b4520-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="b4520-138">Aunque el almacenamiento en caché aumenta la complejidad, es una parte fundamental de cualquier aplicación escalable: mientras que la capa de aplicación se puede escalar fácilmente mediante la adición de más servidores para controlar el aumento de la carga, el escalado del nivel de base de datos suele ser mucho más complicado.</span><span class="sxs-lookup"><span data-stu-id="b4520-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
