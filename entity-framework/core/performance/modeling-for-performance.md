---
title: 'Modelado de rendimiento: EF Core'
description: Modelado eficaz al usar Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657752"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="9afc2-103">Modelado de rendimiento</span><span class="sxs-lookup"><span data-stu-id="9afc2-103">Modeling for Performance</span></span>

<span data-ttu-id="9afc2-104">En muchos casos, la manera de modelar puede tener un impacto profundo en el rendimiento de la aplicación. Aunque un modelo "correcto" y normalizado correctamente es normalmente un buen punto de partida, en las aplicaciones reales, algunos peligros pragmáticos pueden llevar mucho tiempo para lograr un buen rendimiento.</span><span class="sxs-lookup"><span data-stu-id="9afc2-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="9afc2-105">Dado que es bastante difícil cambiar el modelo una vez que una aplicación se ejecuta en producción, merece la pena tener en cuenta el rendimiento al crear el modelo inicial.</span><span class="sxs-lookup"><span data-stu-id="9afc2-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="9afc2-106">Desnormalización y almacenamiento en caché</span><span class="sxs-lookup"><span data-stu-id="9afc2-106">Denormalization and caching</span></span>

<span data-ttu-id="9afc2-107">La *desnormalización* es la práctica de agregar datos redundantes al esquema, normalmente con el fin de eliminar combinaciones al realizar consultas.</span><span class="sxs-lookup"><span data-stu-id="9afc2-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="9afc2-108">Por ejemplo, para un modelo con blogs y publicaciones, donde cada publicación tiene una clasificación, es posible que se le pida que muestre con frecuencia la clasificación promedio del blog.</span><span class="sxs-lookup"><span data-stu-id="9afc2-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="9afc2-109">El enfoque sencillo para esto agruparía las entradas por su blog y calcularía el promedio como parte de la consulta. pero esto requiere una combinación costosa entre las dos tablas.</span><span class="sxs-lookup"><span data-stu-id="9afc2-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="9afc2-110">La desnormalización agregaría el promedio calculado de todos los envíos a una nueva columna en el blog, de modo que se pueda acceder a él de inmediato, sin unirse ni calcular.</span><span class="sxs-lookup"><span data-stu-id="9afc2-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="9afc2-111">Lo anterior se puede ver como una forma de información de agregación de *almacenamiento en caché* de las publicaciones se almacena en caché en su blog. y, al igual que con cualquier almacenamiento en caché, el problema es cómo mantener actualizado el valor almacenado en caché con los datos que almacena en memoria caché.</span><span class="sxs-lookup"><span data-stu-id="9afc2-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="9afc2-112">En muchos casos, es correcto que los datos almacenados en caché se retrasen un poco. por ejemplo, en el ejemplo anterior, suele ser razonable que la puntuación media del blog no esté totalmente actualizada en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="9afc2-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="9afc2-113">Si ese es el caso, puede hacer que se vuelva a calcular cada ahora y, después, a; de lo contrario, se debe configurar un sistema más elaborado para mantener actualizados los valores almacenados en caché.</span><span class="sxs-lookup"><span data-stu-id="9afc2-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="9afc2-114">A continuación se detallan algunas técnicas para la desnormalización y el almacenamiento en caché en EF Core y se apunta a las secciones pertinentes de la documentación.</span><span class="sxs-lookup"><span data-stu-id="9afc2-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="9afc2-115">Columnas calculadas almacenadas</span><span class="sxs-lookup"><span data-stu-id="9afc2-115">Stored computed columns</span></span>

<span data-ttu-id="9afc2-116">Si los datos que se van a almacenar en caché son un producto de otras columnas de la misma tabla, una [columna calculada almacenada](xref:core/modeling/generated-properties#computed-columns) puede ser una solución perfecta.</span><span class="sxs-lookup"><span data-stu-id="9afc2-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="9afc2-117">Por ejemplo, un `Customer` puede tener `FirstName` `LastName` columnas y, pero es posible que sea necesario buscar por el *nombre completo* del cliente.</span><span class="sxs-lookup"><span data-stu-id="9afc2-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="9afc2-118">La base de datos mantiene automáticamente una columna calculada almacenada, que la vuelve a calcular cada vez que se cambia la fila, e incluso puede definir un índice para acelerar las consultas.</span><span class="sxs-lookup"><span data-stu-id="9afc2-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="9afc2-119">Actualizar columnas de caché cuando cambien las entradas</span><span class="sxs-lookup"><span data-stu-id="9afc2-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="9afc2-120">Si la columna almacenada en caché necesita hacer referencia a entradas desde fuera de la fila de la tabla, no se pueden usar columnas calculadas.</span><span class="sxs-lookup"><span data-stu-id="9afc2-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="9afc2-121">Sin embargo, sigue siendo posible volver a calcular la columna cada vez que cambie la entrada; por ejemplo, podría recalcular el promedio de clasificación del blog cada vez que se cambia, agrega o quita una publicación.</span><span class="sxs-lookup"><span data-stu-id="9afc2-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="9afc2-122">Asegúrese de identificar las condiciones exactas en las que es necesario volver a calcular; de lo contrario, el valor almacenado en caché no se sincronizará.</span><span class="sxs-lookup"><span data-stu-id="9afc2-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="9afc2-123">Una forma de hacerlo consiste en realizar la actualización por su cuenta, a través de la API de EF Core normal.</span><span class="sxs-lookup"><span data-stu-id="9afc2-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="9afc2-124">`SaveChanges`[Los eventos](xref:core/logging-events-diagnostics/events) o los [interceptores](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) se pueden usar para comprobar automáticamente si se está actualizando cualquier publicación y para realizar el recálculo de este modo.</span><span class="sxs-lookup"><span data-stu-id="9afc2-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="9afc2-125">Tenga en cuenta que esto normalmente conlleva viajes de ida de base de datos adicionales, ya que se deben enviar comandos adicionales.</span><span class="sxs-lookup"><span data-stu-id="9afc2-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="9afc2-126">En el caso de las aplicaciones más sensibles al rendimiento, se pueden definir desencadenadores de base de datos para realizar automáticamente el recálculo en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="9afc2-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="9afc2-127">Esto guarda el interactivo de la base de datos adicional, se produce automáticamente dentro de la misma transacción que la actualización principal y puede ser más fácil de configurar.</span><span class="sxs-lookup"><span data-stu-id="9afc2-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="9afc2-128">EF no proporciona ninguna API específica para crear o mantener desencadenadores, pero es perfecta para [crear una migración vacía y agregar la definición del desencadenador a través de SQL sin procesar](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="9afc2-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="9afc2-129">Vistas materializadas</span><span class="sxs-lookup"><span data-stu-id="9afc2-129">Materialized views</span></span>

<span data-ttu-id="9afc2-130">Las vistas materializadas son similares a las vistas normales, excepto en que sus datos se almacenan en el disco ("materializado"), en lugar de calcularse cada vez que se consulta la vista.</span><span class="sxs-lookup"><span data-stu-id="9afc2-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="9afc2-131">Esta herramienta es útil cuando no se desea simplemente agregar una única columna de caché a una base de datos existente, sino que se desea almacenar en caché todo el conjunto de resultados de los resultados de una consulta complicada y costosa, como si fuera una tabla normal. Estos resultados se pueden consultar de forma muy barata sin que se produzca ningún cálculo o combinación.</span><span class="sxs-lookup"><span data-stu-id="9afc2-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="9afc2-132">A diferencia de las columnas calculadas, las vistas materializadas no se actualizan automáticamente cuando se modifican sus tablas subyacentes, sino que se deben actualizar manualmente.</span><span class="sxs-lookup"><span data-stu-id="9afc2-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="9afc2-133">Si los datos almacenados en caché se pueden retrasar, la actualización de la vista se puede realizar a través de un temporizador. otra opción consiste en configurar desencadenadores de base de datos para revisar una vista materializada cuando se produzcan determinados eventos de base de datos.</span><span class="sxs-lookup"><span data-stu-id="9afc2-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="9afc2-134">EF no proporciona actualmente ninguna API específica para crear o mantener vistas, materializadas o de otro tipo. pero es perfectamente adecuado [crear una migración vacía y agregar la definición de la vista a través de SQL sin procesar](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="9afc2-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="9afc2-135">Asignación de herencia</span><span class="sxs-lookup"><span data-stu-id="9afc2-135">Inheritance mapping</span></span>

<span data-ttu-id="9afc2-136">Se recomienda leer [la página dedicada en la herencia](xref:core/modeling/inheritance) antes de continuar con esta sección.</span><span class="sxs-lookup"><span data-stu-id="9afc2-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="9afc2-137">EF Core admite actualmente dos técnicas para asignar un modelo de herencia a una base de datos relacional:</span><span class="sxs-lookup"><span data-stu-id="9afc2-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="9afc2-138">**Tabla por jerarquía** (TPH), en la que toda una jerarquía de clases de .net está asignada a una sola tabla de base de datos</span><span class="sxs-lookup"><span data-stu-id="9afc2-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="9afc2-139">**Tabla por tipo** (TPT), en la que cada tipo de la jerarquía de .net se asigna a una tabla diferente en la base de datos.</span><span class="sxs-lookup"><span data-stu-id="9afc2-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="9afc2-140">La elección de la técnica de asignación de herencia puede tener un impacto considerable en el rendimiento de la aplicación; se recomienda medir cuidadosamente antes de confirmar una opción.</span><span class="sxs-lookup"><span data-stu-id="9afc2-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="9afc2-141">A veces, los usuarios eligen TPT porque parece ser la técnica de "limpiador"; una tabla independiente para cada tipo .NET hace que el esquema de la base de datos sea similar a la jerarquía de tipos .NET.</span><span class="sxs-lookup"><span data-stu-id="9afc2-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="9afc2-142">Además, dado que TPH debe representar toda la jerarquía en una sola tabla, las filas tienen *todas* las columnas independientemente del tipo que realmente se mantiene en la fila, y las columnas no relacionadas siempre están vacías y no se utilizan.</span><span class="sxs-lookup"><span data-stu-id="9afc2-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="9afc2-143">Además de parecerse a una técnica de asignación "sin limpieza", muchos consideran que estas columnas vacías ocupan un espacio considerable en la base de datos y pueden afectar también al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="9afc2-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="9afc2-144">Sin embargo, la medición muestra que TPT en la mayoría de los casos es la técnica de asignación inferior desde un punto de vista del rendimiento. Cuando todos los datos de TPH proceden de una sola tabla, las consultas de TPT deben combinarse con varias tablas y las combinaciones son una de las principales fuentes de problemas de rendimiento de las bases de datos relacionales.</span><span class="sxs-lookup"><span data-stu-id="9afc2-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="9afc2-145">Las bases de datos también suelen tratar bien con columnas vacías, y las características como [SQL Server columnas dispersas](/sql/relational-databases/tables/use-sparse-columns) pueden reducir aún más esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="9afc2-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="9afc2-146">Para ver un ejemplo concreto, [vea este criterio de referencia](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) que configura un modelo simple con una jerarquía de 7 tipos; 5000 las filas se inicializan para cada tipo: total de 35000 filas, y la prueba comparativa simplemente carga todas las filas de la base de datos:</span><span class="sxs-lookup"><span data-stu-id="9afc2-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="9afc2-147">Método</span><span class="sxs-lookup"><span data-stu-id="9afc2-147">Method</span></span> |     <span data-ttu-id="9afc2-148">Media</span><span class="sxs-lookup"><span data-stu-id="9afc2-148">Mean</span></span> |   <span data-ttu-id="9afc2-149">Error</span><span class="sxs-lookup"><span data-stu-id="9afc2-149">Error</span></span> |  <span data-ttu-id="9afc2-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="9afc2-150">StdDev</span></span> |     <span data-ttu-id="9afc2-151">Gen. 0</span><span class="sxs-lookup"><span data-stu-id="9afc2-151">Gen 0</span></span> |     <span data-ttu-id="9afc2-152">Gen. 1</span><span class="sxs-lookup"><span data-stu-id="9afc2-152">Gen 1</span></span> |     <span data-ttu-id="9afc2-153">Gen. 2</span><span class="sxs-lookup"><span data-stu-id="9afc2-153">Gen 2</span></span> | <span data-ttu-id="9afc2-154">Allocated</span><span class="sxs-lookup"><span data-stu-id="9afc2-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="9afc2-155">TPH</span><span class="sxs-lookup"><span data-stu-id="9afc2-155">TPH</span></span> | <span data-ttu-id="9afc2-156">132,3 MS</span><span class="sxs-lookup"><span data-stu-id="9afc2-156">132.3 ms</span></span> | <span data-ttu-id="9afc2-157">2,29 MS</span><span class="sxs-lookup"><span data-stu-id="9afc2-157">2.29 ms</span></span> | <span data-ttu-id="9afc2-158">2,03 MS</span><span class="sxs-lookup"><span data-stu-id="9afc2-158">2.03 ms</span></span> | <span data-ttu-id="9afc2-159">8000,0000</span><span class="sxs-lookup"><span data-stu-id="9afc2-159">8000.0000</span></span> | <span data-ttu-id="9afc2-160">3000,0000</span><span class="sxs-lookup"><span data-stu-id="9afc2-160">3000.0000</span></span> | <span data-ttu-id="9afc2-161">1250,0000</span><span class="sxs-lookup"><span data-stu-id="9afc2-161">1250.0000</span></span> |  <span data-ttu-id="9afc2-162">44,49 MB</span><span class="sxs-lookup"><span data-stu-id="9afc2-162">44.49 MB</span></span> |
|    <span data-ttu-id="9afc2-163">TPT</span><span class="sxs-lookup"><span data-stu-id="9afc2-163">TPT</span></span> | <span data-ttu-id="9afc2-164">201,3 MS</span><span class="sxs-lookup"><span data-stu-id="9afc2-164">201.3 ms</span></span> | <span data-ttu-id="9afc2-165">3,32 ms</span><span class="sxs-lookup"><span data-stu-id="9afc2-165">3.32 ms</span></span> | <span data-ttu-id="9afc2-166">3,10 ms</span><span class="sxs-lookup"><span data-stu-id="9afc2-166">3.10 ms</span></span> | <span data-ttu-id="9afc2-167">9000,0000</span><span class="sxs-lookup"><span data-stu-id="9afc2-167">9000.0000</span></span> | <span data-ttu-id="9afc2-168">4000,0000</span><span class="sxs-lookup"><span data-stu-id="9afc2-168">4000.0000</span></span> |         - |  <span data-ttu-id="9afc2-169">61,84 MB</span><span class="sxs-lookup"><span data-stu-id="9afc2-169">61.84 MB</span></span> |

<span data-ttu-id="9afc2-170">Como se puede ver, TPH es considerablemente más eficiente que TPT para este escenario.</span><span class="sxs-lookup"><span data-stu-id="9afc2-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="9afc2-171">Tenga en cuenta que los resultados reales siempre dependen de la consulta específica que se ejecuta y el número de tablas de la jerarquía, por lo que otras consultas pueden mostrar un intervalo de rendimiento diferente. le recomendamos que use este código de referencia comparativa como plantilla para probar otras consultas.</span><span class="sxs-lookup"><span data-stu-id="9afc2-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
